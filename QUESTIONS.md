# Вопросы

1. *Вопрос по тому какой лучше сборщик использовать.*

    Webpack сейчас является, пожалуй, самым распространенным и зрелым сборщиком, так же он имеет множество дополнительных настроек и готовых плагинов. Однако все больше набирает популярность `esbuild`, который ускоряет сборку проекта в разы, вот есть [хорошая статья](https://habr.com/ru/companies/oleg-bunin/articles/660697/) на данную тему

    Сейчас `esbuild` почти достиг зрелого состояния, и его функциональность все больше и больше развивается. Думаю, настало то время, когда можно начинать переводить на него свои проекты. Тем более, что вышло вот такое замечательное [видео "Special Angular Event"](https://www.youtube.com/watch?v=Wq6GpTZ7AX0): webback deprecated, за `esbuild` будущее; Angular 17 использует `esbuild` по дефолту для сборки, а material.angular.io с `esbuild` смог получить ускорение сборки в 2.5 раза

    По этому, **отвечая на вропрос**: я бы рекомендовал в наших реалях смотреть в сторону `esbuild`

    > *А есть ли существенная разница между   "builder": "@angular-devkit/build-angular:browser" и "builder": "@angular-builders/custom-webpack:browser"?*

    Тут я задумался, что подразумевается под существенной разницей)

    И тот и тот механизм работает на webpack, что очевидно, и я бы рассматривал `"@angular-builders/custom-webpack:browser"` как расширение стандартного сборщика (`"@angular-devkit/build-angular:browser"`), добавляющее больше гибкости при настройке процесса сборки.

    По этому, существенных различий в сборке вы не получите, но вот функциональность по настройке сборки у этих вдух пакетов различается.

2. *Кто разрабатывает Zone.js*

    Google

3. *MF на esbuild  переехать можно гладко? Native Federation, кажется - <https://www.angulararchitects.io/en/blog/announcing-native-federation-1-0/>*

    Native Federation - результат создания технологии поваторяющую модель поведения `Module Federation`, которая бы не зависила от `webpack`. `Native Federation` работает со всеми возможными сборщиками, т.е. на выходе он ведет себя точно так же как и `Module Federation`, НО, может работать с различными сборщикаи из-за своей реализации (`Native Federation` вызывается до и после фактического bundler в процессе сборки).

    Что касается перехода - не самом деле структуры очень похожи, отличие будут в:

    1. `withModuleFederationPlugin` будет заменен на `withNativeFederation`

    2. `main.ts` -  необходимо будет запустить `initFederation` функцию с путем до манифеста

        ```ts
        initFederation('/assets/federation.manifest.json')
            .catch(err => console.error(err))
            .then(() => import('./bootstrap'))
            .catch(err => console.error(err));
        ```

    3. Лениво загружаемые модули будут выглядеть чуть иначе

        ```ts
        export const APP_ROUTES: Routes = [
            […],
            {
                path: 'path',
                loadComponent: () => loadRemoteModule('mfe', './Module').then((m) => m.RoutingModule),
            },
            […]
        ];
        ```

    Это основные отличия которые я смог выделить. По ним переезд выглядит не болезненным. А для создания новых проеков на `Native Federation` у нас есть сехматики:

    ```bash
    ng add @angular-architects/native-federation --project shell --port 4200 --type dynamic-host
    ```

    ```bash
    ng add @angular-architects/native-federation --project mfe --port 4201 --type remote
    ```

    Вот есть хорошая [статья](https://www.angulararchitects.io/en/blog/micro-frontends-with-modern-angular-part-1-standalone-and-esbuild/) на данную тему.

4. *MF. А как это с ssr-ом работает?*

    Есть вот такой, довольно понятный [гайд для SSR на NX](https://nx.dev/recipes/angular/module-federation-with-ssr)

    Подгрузка самих модулей и резолв загружаемых зависимостей происходит в рантайме, по этому дополнительных проблем с SSR не видится - общий принцип MF остается тем же.

    Подобного опыта у меня не было, по этому если у вас есть пример приложения с SSR, в который хотелось бы внедирть MF - пишите, буду рад разобраться вместе!

5. *Привелегированные порты*

    Как и сказали на лекции, все зависит от настроек конкретного сервера.

6. *Service Worker. Как тогда инвалидировать кэш самому?*

    `Service Worker` - общая Web технология. Мы же с вами рассмотрели ее использование в Angular через предоставляемые нам механизмы. Собственно сам Angular, при подключении через него `Service Worker` предоставляет несколько стратегий инвалидации кэша: `freshness` (`dataGroups`), `performance` (`dataGroups`); `prefetch` (`assetGroups`), `lazy` (`assetGroups`). Конфигурация подключаемого Angular сервис воркера находится в файле `ngsw-config.json`, т.е. взаимодействовать с сервис воркером созданным Angular мы должны через него.

    > Объект `assetGroups` управляет статическими ресурсами приложения, включая HTML, CSS, JavaScript и изображения;
    >
    > Объект `dataGroups` управляет динамическими ресурсами или запросами API.
    >
    > **assetGroups:**
    >
    > `prefetch`: Эта стратегия загружает все ресурсы при первой загрузке приложения. Она гарантирует, что все ресурсы будут доступны в автономном режиме, но может занять некоторое время для загрузки. Эта стратегия подходит для небольших приложений и ресурсов, которые всегда нужны.
    >
    > `lazy`: Эта стратегия загружает ресурсы только по требованию, когда они запрашиваются. Это ускоряет начальную загрузку, но ресурсы не будут доступны в автономном режиме, пока они не будут запрошены хотя бы один раз. Подходит для больших приложений с ресурсами, которые редко используются.
    >
    > **dataGroups:**
    >
    > `performance`: Эта стратегия используется для ресурсов, для которых самый важный критерий — скорость ответа. Service Worker будет отдавать данные из кэша, если они там имеются. Если же в кэше данных нет, то запрос будет произведён на сервер. Этот метод уменьшает задержки подключений и является подходящим для большинства видов API-запросов.
    >
    > `freshness`: Эта стратегия используется для случаев, когда необходимо гарантированное обновление данных, пусть даже за счет некоторой задержки. Service Worker всегда обращается к сети, чтобы получить данные. Если это не возможно (например, в режиме оффлайн), то отдает данные из кэша.

    Однако, т.к. `Service Worker`, повторюсь, общая Web технология, то мы можем подключить ее сами, без использования механизмов Angular. Подключая сервис воркер напрямую, мы должны будем самостоятельно настроить его, в том числе схоранение и инвалидацию кэша нам тоже нужно будетет реализовывать самим. Вот тут [хорошая статья](https://dev.to/paco_ita/service-workers-and-caching-strategies-explained-step-3-m4f) в которой описывается наивное подключение `Service Worker` и реализацию кэширования. Кэширование осуществляется через API [`Cache Storage`](https://developer.mozilla.org/ru/docs/Web/API/CacheStorage). Остается только реализовать :smile:

7. *Service Worker. Апишки кешить таргетировано можно(определенные правила навешивать кеширования)? есть примеры как юзать?*

    Да, мы можем выполнять таргетированное кэширование API-сервисов, с использованием определенных правил кеширования. За управление кешированием отвечает файл конфигурации Service Worker — `ngsw-config.json`, в частности, нам потребуется конфигурация `dataGroups` для управления динамическими ресурсами и запросами API. В конфиге мы можем указать `urls` для указания шаблонов соответствия URL которые мы хотим кэшировать и `cacheConfig` для определения поведения кэширования запросов по путям из `urls`.

    Вот небольшой пример:

    ```json
    {
        "$schema": "./node_modules/@angular/service-worker/config/schema.json",
        "index": "/index.html",
        "assetGroups": [
            {...}
        ],
        "dataGroups": [
            {
                "name": "api-cache",
                "urls": [
                    "/api/**"
                ],
                "cacheConfig": {
                    "strategy": "freshness",
                    "maxSize": 100,
                    "maxAge": "3d",
                    "timeout": "1m"
                }
            }
        ]
    }
    ```

    В параметрах `cacheConfig` устанавливаем:

    - `"strategy": "freshness"` - это означает, что `Service Worker` всегда будет сперва обращаться к сети для получения данных.

        Чуть подробней стратегии разобрали в предыдущем запросе

    - `"maxSize": 100` - это ограничивает размер кэша до 100 запросов.

        Параметр `maxSize` в секции `cacheConfig` конфигурационного файла `ngsw-config.json` указывает максимальное количество запросов, которые могут быть сохранены в кэше для определенной группы данных. Цифра, указанная в `maxSize`, представляет максимальное количество ответов от сервера (API-запросов, например), которые будут кэшированы. Если число кэшированных запросов достигает этого предела, то самые старые запросы начнут удаляться, чтобы освободить место для новых.

        Этот параметр помогает контролировать использование памяти, задавая ограничения на объем кешированных данных.

    - `"maxAge": "3d"` - это значит, что запросы, которым больше 3-х дней, будут удаляться из кэша.

        Размер `maxAge` можно задавать в различных единицах измерения времени, таких как часы (h), минуты (m), секунды (s). Например, `maxAge: "2h"` означает, что данные будут удаляться из кэша через 2 часа после их создания.

        Этот параметр очень важен, потому что он позволяет контролировать объём используемого пространства кэша и обеспечивает обновление старых данных.

    - `"timeout": "1m"` - при этом значении, если сетевой запрос длится дольше 1 минуты, сервис воркер вернет кэшированный ответ.

        Данный параметр наиболее актуален для стратегии кеша `freshness`, когда service worker сначала пытается получить свежие данные из сети. Если данные из сети не поступают за заданный период времени (время `timeout`), service worker вместо этого вернет сохраненные в кеше данные. Значение `timeout` указывается в минутах или секундах. Например, `timeout: "1m"` означает, что если сетевой запрос занимает больше 1 минуты, service worker отдаст данные из кеша.

        Если данные не получены за заданный период времени и нет данных в кеше, service worker вернет ошибку.

        Этот параметр помогает обеспечить плавное и быстрое представление данных для пользователей, даже когда запросы занимают больше времени, чем ожидалось.

8. *Кстати, two-way binding адаптирован? Того же ngModel например*

    На сколько я понял - еще нет. Но работы активно ведутся, будем ждать!
